<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慌</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.慌.com/"/>
  <updated>2020-12-27T14:28:05.234Z</updated>
  <id>http://www.慌.com/</id>
  
  <author>
    <name>Paix Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>efficient-dart笔记</title>
    <link href="http://www.慌.com/2020/12/28/efficient-dart%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.慌.com/2020/12/28/efficient-dart%E7%AC%94%E8%AE%B0/</id>
    <published>2020-12-28T02:02:07.210Z</published>
    <updated>2020-12-27T14:28:05.234Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Style"><a href="#Style" class="headerlink" title="Style"></a>Style</h2><ul><li><p>import/export的顺序</p><p>dart包 -&gt; flutter及第三方插件的package -&gt; 项目中的相对路径文件 -&gt; export，每个部分用空行隔开。每个部分内按字母顺序排序。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import &#39;dart:async&#39;</span><br><span class="line">import &#39;dart:convert&#39;</span><br><span class="line"></span><br><span class="line">import &#39;package:flutter&#x2F;material.dart&#39;</span><br><span class="line">import &#39;package:redux&#x2F;redux.dart&#39;;</span><br><span class="line"></span><br><span class="line">import &#39;actions.dart&#39;</span><br><span class="line">import &#39;model.dart&#39;</span><br><span class="line"></span><br><span class="line">export &#39;src&#x2F;example.dart&#39;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>一行代码不要超过80个字符</p><p>超过80个字符会降低代码可读性。</p><p>如果变量名太长<em>VeryLongCamelCaseClassNames</em>，考虑下是不是每个单词都是必要的。</p></li><li><p>在所有程序控制流中使用花括号。</p><p>为了避免Dangling else 问题。<a href="https://en.wikipedia.org/wiki/Dangling_else" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Dangling_else</a></p><p>除非使用if时，没有else，并且代码很短，一行就可以放下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(arg &#x3D;&#x3D; null) return defaultValue;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Documentation"><a href="#Documentation" class="headerlink" title="Documentation"></a>Documentation</h2><ul><li><p>像写句子一样写注释</p><p>开头首字母大写，结尾有句号。</p></li><li><p>块注释</p><p>暂时注释掉某行代码时可以使用/*…*/，通常情况都应该使用//。</p></li><li><p>dart支持/**…*/和///两种文档注释，建议用///。</p><p>///更紧凑，而/**…*/会增加单独的两行，并且///在使用*写list时更易读。</p></li><li><p>库文档注释</p><p><strong>内容：</strong></p><ul><li>一句话阐述库的功能</li><li>库中的术语解释</li><li>代码示例</li><li>链接到常用和重要的类和方法</li><li>链接到外部引用</li></ul><p><strong>位置：</strong>库文件最开头，library行（library可以省略）前面。</p><p>考虑给私有API也写文档注释，对于代码维护者理解代码很有用。</p><p>避免多余的上下文。类名，实现的接口，方法签名很明显，应该省略，注释应专注于读者不知道的内容。</p><p>方法的注释最好以第三人称单数动词开头。</p><p>只给getter，setter中的一个加注释，如果两个都有注释，setter的注释会被省略。</p></li><li><p>文档书写规范</p><p>链接：<a href="https://en.wikiversity.org/wiki/Technical_writing/Style" target="_blank" rel="noopener">https://en.wikiversity.org/wiki/Technical_writing/Style</a></p><p>使用‘’this‘’而不是‘’the‘’来指代方法或变量。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li><p>lib/src路径下的文件被指定为库的私有文件，不要导入其他库src下的文件。</p></li><li><p>lib路径外部的文件可以用相对路径导入lib外的其他文件。</p></li><li><p>使用??把null转换为boolean值。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;如果optionalThing是null，这段代码会报错</span><br><span class="line">if (optionalThing?.isEnabled) &#123;do something&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;应该用这种写法</span><br><span class="line">optionalThing?.isEnabled ?? false;</span><br></pre></td></tr></table></figure></li><li><p>直接把两行字符串放在一起，或使用插入符号$比使用+号拼接更简洁。如：</p></li></ul><ul><li><p>使用.isEmpty/.isNotEmpty判断集合是否为空，而不是用.length == 0。前者相对更快，可读性更好。</p></li><li><p>需要对原集合进行修改并返回一个新集合时，使用.map和.where，而不是用for循环。前者的代码更简洁，并且读者更容易理解代码的意图。</p></li><li><p>使用新方法遍历集合时，使用for…in…，而不是.forEach。</p></li><li><p>如果只是想拷贝集合并保留原来的类型，使用toList。需要修改类型时，用List.from。</p></li><li><p>使用whereType方法筛选出集合中的指定类型。</p></li><li><p>如果List.from&lt;T&gt;和.map&lt;T&gt;可以实现需求，不要使用cast。cast很慢并且可能失败。</p><p>减少cast使用的三种方法：</p><ul><li>在声明集合变量时使用正确的类型。</li><li>在访问集合内变量的时候进行cast，而不是对整个集合cast。</li><li>使用List.from。</li></ul></li><li><p>需要给闭包方法命名时，使用方法声明语句。</p></li><li><p>仅在以下两种情况使用this</p><ul><li>形参和成员变量重名；</li><li>this指向构造器。</li></ul></li><li><p>尽量在声明时初始化变量，可以防止忘记初始化某个变量，并且代码更简洁。</p></li><li><p>避免多余的const。不需要写const的场景：</p><ul><li>const 集合中</li><li>const 构造方法中</li><li>元数据注释</li><li>const变量声明的初始化</li></ul></li><li><p>switch case语句中的case后面</p></li><li><p>使用on捕获需要关注的异常，而不是直接捕获所有异常。</p></li><li><p>Error代表代码错误，即bug，如果不是bug，不要抛出error，而应该抛出exception。</p></li><li><p>发生Error时应中断运行，打印堆栈信息。</p></li><li><p>若要在捕获后重新抛出异常，使用rethrow，rethrow可以保留原始的堆栈信息。</p></li><li><p>使用await可以提高可读性，而不是.then。</p></li><li><p>避免不必要的async。需要使用async的场景：</p><ul><li>使用了await</li><li>异步返回error</li><li>异步返回一个值</li></ul></li><li><p>不要直接使用Completer，Future.then更简洁，并更容易处理error。</p></li><li><p>判断FutureOr&lt;T&gt;时，应判断is Future&lt;T&gt;，如果判断is T，在T为Object时，Future也将返回true，因为Future是Object的子类。</p></li></ul><h2 id="Design"><a href="#Design" class="headerlink" title="Design"></a>Design</h2><ul><li><p>使用一致的，常用的术语命名。降低用户的学习成本。</p></li><li><p>把最有描述性的名词放在命名的末尾。</p></li><li><p>让代码读起来像句子。通顺并且表意清晰。</p></li><li><p>用名词命名非布尔类型的变量。</p></li><li><p>布尔类型的变量以 is, was, will, has, can, should, must,等开头。但是在可选命名参数中，可以省略。</p></li><li><p>命名布尔变量时使用“积极的”形容词，如“isConnected”，而不是“isDisconnected”。</p></li><li><p>如果一个方法返回一个值，应该以名词或非命令动词开头。如elementAt，firstWhere，codeUnitAt</p></li><li><p>方法的命令应描述方法做什么，而不是怎么做。</p></li><li><p>避免方法命名以get开头，如果是get something，应定义为getter。</p><p>如需要参数等原因不能定义为getter，可以 简单把get词去掉，或用create, download, fetch, calculate, request等词代替。</p></li><li><p>如果一个方法是把对象的状态拷贝到新对象，使用to___()。</p></li><li><p>如果原对象包含新对象的引用，对原对象的修改会影响新对象，使用as___()。</p></li><li><p>避免在方法命名中描述参数，调用的时候用户是可以看到的，所以不用。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//good</span></span><br><span class="line">list.add(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">//bad</span></span><br><span class="line">list.addElement(element);</span><br></pre></td></tr></table></figure></li><li><p>声明泛型时使用熟悉的字母，如：List&lt;E&gt;-&gt;element, Map&lt;K, V&gt; -&gt;key, value。其他使用T, S, U。</p></li><li><p>避免定义只包含静态成员的类，应使用库成员，将库作为命名空间。</p></li><li><p>不要继承/实现一个不打算被继承/实现的类。如果某个类允许被继承/实现，应在文档注释或以<code>__Base</code>来命名类。</p></li><li><p>如果类的所有字段都是final的，并且构造器中只是初始化它们，考虑使用const修饰构造器。</p></li><li><p>应使用getter，而不是方法的场景：</p><ul><li>只关注返回的结果</li><li>不做大量计算</li><li>不修改对象</li><li>多次调用返回同样结果</li><li>返回的结果只包含对象的一部分，（如果包含整个对象，使用to__或as__）</li></ul></li><li><p>应该是setter，而不是方法的场景：</p><ul><li>只需要一个参数，并且不返回结果</li><li>修改了对象的某些状态</li><li>多次操作时，第二次操作应该没有效果</li></ul></li><li><p>不要定义只有setter而没有getter的属性。</p></li><li><p>不要让一个bool，double，int 或 num的成员返回null。如果必须，在文档里写明返回null的情况。</p></li><li><p>方法应避免返回this，用dart的级联就好。</p></li><li><p>应在声明时写明类型的场景：</p><ul><li>字段和变量的类型不明显（Obvious）时；</li><li>未实例化的局部变量</li><li>避免声明匿名方法中已推断出类型的参数</li><li>在类的调用时避免多余的类型声明。<code>Set&lt;String&gt; things = Set();</code> 或者<code>var things = Set&lt;String&gt;();</code> 未写明的类型会被推断出来。</li><li>dart 推断的类型不是想要的类型</li></ul></li><li><p>不要给setter指定返回值，setter的返回值是void</p></li><li><p>使用typedef的正确方式：<code>typedef Comparision&lt;T&gt; = int Function(T, T);</code></p></li><li><p>使用inline方法类型。如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilteredObservable</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="built_in">bool</span> <span class="built_in">Function</span>(Event) _perdicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">Function</span>(Event) notify()&#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非这个类型很长并且经常使用时才用<code>typedef</code>。</p></li><li><p>避免使用dynamic除非你想禁用静态类型检查。对dynamic类型的任何访问在编译时都不会报错，这样会有风险。</p></li><li><p>异步方法没有返回值时，用Future&lt;void&gt;。</p></li><li><p>避免使用FutureOr&lt;T&gt;作为返回值，只使用Future&lt;T&gt;。</p></li><li><p>避免使用布尔类型的positional参数，这会降低可读性。</p></li><li><p>实现一个接收范围参数的方式时，包含start，不包含end。</p></li><li><p>重写==时，也要重写hashCode，不然map等基于hash的集合会出错。</p></li><li><p>==操作符应遵循以下原则</p><ul><li>a == a 应返回true</li><li>a == b和b == a的返回结果应一致</li><li>如果a==b, b==c，则a==c。</li></ul></li><li><p>避免重写可改变的类的一致操作。大多数基于hash的集合假设对象的hash是永远不变的。</p></li><li><p>不要在==中作判空。dart只有在==两边都不为空时才执行==操作。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Style&quot;&gt;&lt;a href=&quot;#Style&quot; class=&quot;headerlink&quot; title=&quot;Style&quot;&gt;&lt;/a&gt;Style&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;import/export的顺序&lt;/p&gt;
&lt;p&gt;dart包 -&amp;gt; flutter及第三方插件
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unity路径及权限</title>
    <link href="http://www.慌.com/2020/08/05/Unity%E8%B7%AF%E5%BE%84%E5%8F%8A%E6%9D%83%E9%99%90/"/>
    <id>http://www.慌.com/2020/08/05/Unity%E8%B7%AF%E5%BE%84%E5%8F%8A%E6%9D%83%E9%99%90/</id>
    <published>2020-08-05T06:06:38.000Z</published>
    <updated>2020-08-05T10:30:39.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Application.dataPath &#x3D;&#x3D; &#x2F;data&#x2F;app&#x2F;com.DefaultCompany.StorageDemo-6I87J4b-NwZhqATGs7joaA&#x3D;&#x3D;&#x2F;base.apk</span><br><span class="line">    </span><br><span class="line">Application.streamingAssetsPath &#x3D;&#x3D; file:&#x2F;&#x2F;&#x2F;data&#x2F;app&#x2F;com.DefaultCompany.StorageDemo-6I87J4b-NwZhqATGs7joaA&#x3D;&#x3D;&#x2F;base.apk!&#x2F;assets</span><br><span class="line">    </span><br><span class="line">Application.persistentDataPath &#x3D;&#x3D; &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.DefaultCompany.StorageDemo&#x2F;files</span><br><span class="line">    </span><br><span class="line">Application.temporaryCachePath &#x3D;&#x3D; &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;Android&#x2F;data&#x2F;com.DefaultCompany.StorageDemo&#x2F;cache</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;路径&quot;&gt;&lt;a href=&quot;#路径&quot; class=&quot;headerlink&quot; title=&quot;路径&quot;&gt;&lt;/a&gt;路径&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="Unity" scheme="http://www.xn--9hu.com/categories/Unity/"/>
    
    
  </entry>
  
  <entry>
    <title>批处理笔记</title>
    <link href="http://www.慌.com/2020/08/01/%E6%89%B9%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/"/>
    <id>http://www.慌.com/2020/08/01/%E6%89%B9%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-01T12:37:20.000Z</published>
    <updated>2020-08-03T03:58:01.943Z</updated>
    
    <content type="html"><![CDATA[<p>批处理基本语法之外的知识点，包含CMD命令。</p><a id="more"></a><h4 id="获取bat文件所在目录"><a href="#获取bat文件所在目录" class="headerlink" title="获取bat文件所在目录"></a>获取bat文件所在目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> curPath=%~dp0</span><br><span class="line">::%0表示bat文件的全路径</span><br><span class="line">::dp表示扩展，d表示向前扩展至驱动器，p表示向后扩展至路径</span><br><span class="line">::例如 D:\example\test.bat</span><br><span class="line">::%0 == D:\example\test.bat</span><br><span class="line">::%~d0 == D:</span><br><span class="line">::%~p0 == \example\</span><br></pre></td></tr></table></figure><h4 id="添加右键菜单"><a href="#添加右键菜单" class="headerlink" title="添加右键菜单"></a>添加右键菜单</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AllFilesystemObjects\shell\install</span><br><span class="line">reg add HKEY_LOCAL_MACHINE\SOFTWARE\Classes\AllFilesystemObjects\shell\install\<span class="built_in">command</span> /t reg_sz /d <span class="string">"install.bat %%1"</span></span><br><span class="line">::将AllFilesystemObjects替换为.apk则只添加到apk文件的右键菜单。</span><br></pre></td></tr></table></figure><h4 id="获取输出"><a href="#获取输出" class="headerlink" title="获取输出"></a>获取输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f <span class="string">"delims="</span> %%i <span class="keyword">in</span> (<span class="string">'命令'</span>) <span class="keyword">do</span> <span class="built_in">echo</span> get %%i</span><br></pre></td></tr></table></figure><h4 id="延时一秒"><a href="#延时一秒" class="headerlink" title="延时一秒"></a>延时一秒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping -n 2 127.0.0.1 &gt;nul</span><br><span class="line">::-n 2 表示发送次数，设置为2间隔大概为一秒</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;批处理基本语法之外的知识点，包含CMD命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="http://www.xn--9hu.com/categories/programming/"/>
    
    
      <category term="batchscript" scheme="http://www.xn--9hu.com/tags/batchscript/"/>
    
  </entry>
  
  <entry>
    <title>布局约束</title>
    <link href="http://www.慌.com/2020/07/21/%E5%B8%83%E5%B1%80%E7%BA%A6%E6%9D%9F/"/>
    <id>http://www.慌.com/2020/07/21/%E5%B8%83%E5%B1%80%E7%BA%A6%E6%9D%9F/</id>
    <published>2020-07-21T11:40:17.000Z</published>
    <updated>2020-07-21T13:01:01.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先，上层widget向下层widget传递约束条件</p><p>然后，下层widget向上层widget传递大小信息</p><p>最后，上层widget决定下层widget的位置</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;首先，上层widget向下层widget传递约束条件&lt;/p&gt;
&lt;p&gt;然后，下层widget向上层widget传递大小信息&lt;/p&gt;
&lt;p&gt;最后，上层widget决定下层widget的位置&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
    
      <category term="flutter" scheme="http://www.xn--9hu.com/categories/flutter/"/>
    
    
      <category term="layout" scheme="http://www.xn--9hu.com/tags/layout/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 测试</title>
    <link href="http://www.慌.com/2020/07/13/Flutter-%E6%B5%8B%E8%AF%95/"/>
    <id>http://www.慌.com/2020/07/13/Flutter-%E6%B5%8B%E8%AF%95/</id>
    <published>2020-07-13T03:17:19.000Z</published>
    <updated>2020-07-29T12:41:01.685Z</updated>
    
    <content type="html"><![CDATA[<p> 单元测试（Unit Test）, 组件测试（Widget Test）, 集成测试（Integration Test）。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>单元测试</strong><br>单元测试指测试单个方法或类是否能执行。单元测试不会从磁盘读取数据，也不会渲染界面或接收用户操作。单元测试的目标是验证逻辑单元的正确性。<br>如果有依赖则可使用 <code>mockito</code> 生成模拟数据。</p><p><strong>Widget测试</strong><br>Widget测试的是单个Widget。Widget测试的目标是Widget能如预期的那样显示和交互。</p><p><strong>集成测试</strong><br>集成测试测试的是整个应用或应用的很大一部分。通常在真实设备或模拟器上运行。<br>集成测试的目标是整个应用能正确运行。<br>集成测试还可以验证应用的性能。</p><p><strong>经过充分测试的应用具有非常多的单元和Widget测试，通过代码覆盖（code coverage）进行跟踪，以及覆盖所有重要使用场景的大量集成测试。</strong></p><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ol><li><p>编写待测试类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/main.dart</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> increment() =&gt; value++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> decrement() =&gt; value--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写测试</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test/counter_test.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:hello_test/main.dart'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">    <span class="keyword">final</span> counter = Counter();</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'increment'</span>, () &#123;</span><br><span class="line">      counter.increment();</span><br><span class="line">      expect(counter.value, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    test(<span class="string">'decrement'</span>, () &#123;</span><br><span class="line">      <span class="comment">// final counter = Counter();</span></span><br><span class="line">      counter.decrement();</span><br><span class="line">      expect(counter.value, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    test(<span class="string">'increment'</span>, () &#123;</span><br><span class="line">      counter.increment();</span><br><span class="line">      expect(counter.value, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分组</p><p>使用<code>group(...)</code> 对测试分组</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  group(<span class="string">'Counter'</span>, () &#123;</span><br><span class="line">    <span class="keyword">final</span> counter = Counter();</span><br><span class="line"></span><br><span class="line">    test(<span class="string">'increment'</span>, () &#123;</span><br><span class="line">      counter.increment();</span><br><span class="line">      expect(counter.value, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    test(<span class="string">'decrement'</span>, () &#123;</span><br><span class="line">      <span class="comment">// final counter = Counter();</span></span><br><span class="line">      counter.decrement();</span><br><span class="line">      expect(counter.value, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    test(<span class="string">'increment'</span>, () &#123;</span><br><span class="line">      counter.increment();</span><br><span class="line">      expect(counter.value, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  group(<span class="string">'Counter2'</span>, ()&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p><p>可以打开测试代码，直接按<code>F5</code>运行。</p><p>或在终端输入<code>flutter test test/counter_test.dart</code> 运行指定测试文件或<code>flutter test</code> 运行所有测试文件。</p></li></ol><h2 id="Widget测试"><a href="#Widget测试" class="headerlink" title="Widget测试"></a>Widget测试</h2><ol><li><p>编写测试Widget</p><p>使用CounterApp的代码。</p></li><li><p>编写测试代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test/Widget_test.dart</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter_test/flutter_test.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:hello_test/main.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">    testWidgets(<span class="string">'Counter App'</span>, (WidgetTester tester) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> tester.pumpWidget(MyHomePage(</span><br><span class="line">        title: <span class="string">'Test'</span>,</span><br><span class="line">      ));</span><br><span class="line">      expect(find.text(<span class="string">'0'</span>), findsOneWidget);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">await</span> tester.tap(find.byType(FloatingActionButton));</span><br><span class="line">      <span class="keyword">await</span> tester.pump();</span><br><span class="line">      expect(find.text(<span class="string">'1'</span>), findsOneWidget);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>单元测试和Widget测试都只是测试代码的一部分，而集成测试测试的是应用整体的运行情况，包括实际运行在真机上的性能数据。</p><p>运行集成测试要使用 <a href="https://api.flutter.dev/flutter/flutter_driver/flutter_driver-library.html" target="_blank" rel="noopener">flutter_driver</a>。</p><ol><li><p>编写待测程序代码；</p></li><li><p>导入flutter_driver</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dev_dependencies:</span><br><span class="line">  flutter_driver:</span><br><span class="line">    sdk: flutter</span><br><span class="line">  test: any</span><br></pre></td></tr></table></figure></li><li><p>在项目根目录新建<code>test_driver</code>文件夹</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 单元测试（Unit Test）, 组件测试（Widget Test）, 集成测试（Integration Test）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://www.xn--9hu.com/categories/flutter/"/>
    
    
      <category term="test" scheme="http://www.xn--9hu.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>service保活</title>
    <link href="http://www.慌.com/2020/07/12/service%E4%BF%9D%E6%B4%BB/"/>
    <id>http://www.慌.com/2020/07/12/service%E4%BF%9D%E6%B4%BB/</id>
    <published>2020-07-12T13:16:55.000Z</published>
    <updated>2020-07-12T13:56:08.400Z</updated>
    
    <content type="html"><![CDATA[<p>Android Service保活的几种方式。</p><a id="more"></a><ul><li><p>onStartCommand方法中返回START_STICKY</p><p>onStartCommand的返回值用来指定系统在Service被杀时如何处理。</p><ul><li><strong>START_STICKY</strong> Service被杀后，系统会重新创建Service，传递给新创建Service的是空Intent；</li><li><strong>START_NOT_STICKY</strong> Service被杀后，系统不会重新创建Service；</li><li><strong>START_REDELIVER_INTENT</strong> Service被杀后，系统会重新创建Service，并把最后一次接收到的Intent发送给新创建的Service。</li></ul></li><li><p>提高优先级（Intent-filter中设置android:priority=”1000”）</p></li><li><p>startForeground()启动前台进程</p></li><li><p>onDestory中重启Service</p></li><li><p>onDestory中发送广播，广播接收器启动Service</p></li><li><p>监听系统广播，判断Service状态，若Service被杀则启动Service</p></li><li><p>安装到system/app，使其成为系统应用</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android Service保活的几种方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://www.xn--9hu.com/categories/android/"/>
    
    
      <category term="tips" scheme="http://www.xn--9hu.com/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://www.慌.com/2020/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.慌.com/2020/07/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-07-09T10:43:45.000Z</published>
    <updated>2020-07-29T12:17:55.596Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式学习笔记。</p><a id="more"></a><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p><strong><code>+</code></strong> 表示前面的字符可以出现一次或多次。</p><p>如：go+gle可以匹配gogle、goooooogle。</p><p><strong><code>*</code></strong>表示前面的字符可以出现零次，一次或多次。</p><p>如：go*gle可以匹配ggle、gogle、goooogle。</p><p><strong><code>?</code></strong> 表示前面的字符可以出现零次或一次。</p><p>如：go?gle可以匹配ggle、gogle。</p><p><strong><code>.</code></strong> 匹配除换行符\n外的任意单字符。</p><blockquote><p> 在 + * 之后放置 ? ，可从贪婪模式变为非贪婪模式。</p></blockquote><p><code>^</code> 匹配字符串的起始位置，除非在方括号中使用，表示不接受该方括号表达式内的字符集合。</p><p><code>$</code> 匹配字符串的结束位置，如果设置了Multiline属性，则也匹配\n或\r。</p><hr><h3 id="非打印字符（空白字符）"><a href="#非打印字符（空白字符）" class="headerlink" title="非打印字符（空白字符）"></a>非打印字符（空白字符）</h3><p><code>\cx</code> 匹配由x指明的控制字符，如<code>\cM</code>匹配一个control+M或回车符。x必须是A-Z或a-z之一。</p><p><code>\f</code>匹配一个换页符。</p><p><code>\n</code>匹配一个换行符，如<code>^\n</code>可匹配所有空行。</p><p><code>\r</code>匹配一个回车符。</p><p><code>\s</code>匹配一个空白字符，如空格，制表符，换页符等等，等价于<code>[\f\n\r\t\v]</code>。</p><p><code>\S</code>匹配一个非空白字符，等价于<code>\[^\f\n\r\t\v\]</code>。</p><p><code>\t</code>匹配制表符。</p><p><code>\v</code>匹配垂直制表符。</p><hr><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符表示给定组件必须出现多少次才能匹配，有 <code>+</code>，<code>*</code>，<code>?</code>，<code>{n}</code>，<code>{n,}</code>，<code>{n, m}</code>六种。</p><p><code>{n}</code> n是一个非负整数，匹配确定的n次。</p><p><code>{n,}</code> n是一个非负整数，匹配至少n次。</p><p><code>{n,m}</code> n,m均为非负整数，n&lt;=m，匹配最少n次，最多m次。</p><hr><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p><code>^</code> <code>$</code> <code>\b</code> <code>\B</code></p><p>\b 匹配一个单词边界，即字母和空格之间的位置。</p><p>\B 非单词边界匹配。</p><p><strong>限定符和定位符不能一起使用。</strong></p><p><code>(pattern)</code> 匹配pattern并获取这一匹配，所获取的匹配可以从产生的matches集合中得到。</p><p><code>(?:pattern)</code> 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用“或”（|）来组合一个模式的各个部分是很有用，例如，<code>industrial(?:y|lies)</code>就是一个比<code>industry|industries</code>更简略的表达式。</p><p><code>(?=pattern)</code>正向肯定预查，在任何匹配pattern的字符串开始处开始匹配查找字符串。这是一个非获取匹配。例如：<code>Windows(?=95|98|NT|2000)</code>能匹配”Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p><p><code>(?!pattern)</code>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配。例如<code>Windows (?!95|98|NT|2000)</code>可以匹配“Windows3.1”中的Windows，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符。</p><p><code>(?&lt;=pattern)</code> 反向肯定预查，与正向肯定预查类似，只是方向相反。例如<code>(?&lt;=95|98|NT|2000)Windows</code>能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</p><p><code>(?&lt;!pattern)</code> 反向否定预查，与正向否定预查类似，只是方向相反。例如<code>(?&lt;!95|98|NT|2000)Windows</code>能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。 </p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p><code>g</code>: global，全局标记</p><p><code>i</code>: case insensitive，忽略大小写</p><p><code>m</code>: multiline，多行匹配</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式学习笔记。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="http://www.xn--9hu.com/categories/programming/"/>
    
    
      <category term="regex" scheme="http://www.xn--9hu.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>Matrix &amp; Transform</title>
    <link href="http://www.慌.com/2020/07/08/Matrix-Transform/"/>
    <id>http://www.慌.com/2020/07/08/Matrix-Transform/</id>
    <published>2020-07-08T00:44:37.000Z</published>
    <updated>2020-07-29T11:24:56.656Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵概念及在Flutter中的使用。</p><a id="more"></a><h2 id="矩阵定义"><a href="#矩阵定义" class="headerlink" title="矩阵定义"></a>矩阵定义</h2><p>由m * n 个数 a<sub>ij</sub>排成的m行n列的数表成为m行n列的矩阵，简称m*n矩阵，记作：</p><p><img src="/2020/07/08/Matrix-Transform/definition.svg" alt></p><p>m * n 矩阵A也记作A<sub>mn</sub>。</p><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><h4 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h4><p><img src="/2020/07/08/Matrix-Transform/add.svg" alt></p><h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p><img src="/2020/07/08/Matrix-Transform/subtract.svg" alt></p><h4 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h4><p><img src="/2020/07/08/Matrix-Transform/num_multi.svg" alt></p><h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>矩阵乘法必须在第一个矩阵A的列数和第二个矩阵B的行数相等时才能用。</p><p>如果A是m * n矩阵，B是n*p矩阵，相乘结果C是m * p 矩阵。</p><p><img src="/2020/07/08/Matrix-Transform/multi_comp.svg" alt></p><p><img src="/2020/07/08/Matrix-Transform/multi.svg" alt></p><h2 id="各种矩阵"><a href="#各种矩阵" class="headerlink" title="各种矩阵"></a>各种矩阵</h2><h4 id="单位矩阵"><a href="#单位矩阵" class="headerlink" title="单位矩阵"></a>单位矩阵</h4><p>单位矩阵是指从左上角到右下角的对角线上的元素为1，其他为0的矩阵。</p><p>任何矩阵和单位矩阵相乘都等于矩阵本身。</p><p>n阶单位矩阵记为I<sub>n</sub> 或E<sub>n</sub>。</p><p>单位矩阵满足：AI<sub>n</sub> = A 和 I<sub>n</sub>B = B。</p><h4 id="行矩阵，列矩阵"><a href="#行矩阵，列矩阵" class="headerlink" title="行矩阵，列矩阵"></a>行矩阵，列矩阵</h4><p>表示平移的三个数据在一行就是行矩阵，表示平移的三个数据在一列就是列矩阵。</p><p>如下“平移 旋转 缩放”截图中的矩阵就是列矩阵。</p><h4 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h4><p>将矩阵的行和列互换后得到转置矩阵，记作A<sup>T</sup> 。</p><p>A为m<em>n矩阵，则A<sup>T</sup>为n\</em>m矩阵。</p><h2 id="平移-旋转-缩放"><a href="#平移-旋转-缩放" class="headerlink" title="平移 旋转 缩放"></a>平移 旋转 缩放</h2><p><img src="/2020/07/08/Matrix-Transform/transform.png" alt></p><h2 id="在Flutter中使用矩阵"><a href="#在Flutter中使用矩阵" class="headerlink" title="在Flutter中使用矩阵"></a>在Flutter中使用矩阵</h2><p>Flutter中使用<code>Matrix4</code>类进行矩阵变换。矩阵在Matrix4中采用列存储，即索引的0-4为矩阵的第一列，而非第一行。</p><p>使用<code>Transform</code>组件可以将矩阵变换应用到UI。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Matrix4 _getTransform() &#123;</span><br><span class="line">  <span class="comment">//初始化一个单位矩阵</span></span><br><span class="line">  <span class="keyword">return</span> Matrix4.identity()</span><br><span class="line">    <span class="comment">//将index(3,2)的实现透视效果</span></span><br><span class="line">    ..setEntry(<span class="number">3</span>, <span class="number">2</span>, <span class="number">0.001</span>)</span><br><span class="line">    ..rotateX(rotX)</span><br><span class="line">    ..rotateY(rotY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _setRot(DragUpdateDetails details) &#123;</span><br><span class="line">  rotX = -(<span class="number">150</span> - details.localPosition.dy) / <span class="number">150</span> * pi / <span class="number">6</span>;</span><br><span class="line">  rotY = (<span class="number">150</span> - details.localPosition.dx) / <span class="number">150</span> * pi / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> MaterialApp(</span><br><span class="line">    home: Scaffold(</span><br><span class="line">      body: Center(</span><br><span class="line">        child: GestureDetector(</span><br><span class="line">          onPanUpdate: (details) &#123;</span><br><span class="line">            setState(() =&gt; _setRot(details));</span><br><span class="line">          &#125;,</span><br><span class="line">          child: Transform(</span><br><span class="line">            transform: _getTransform(),</span><br><span class="line">            child: Container(</span><br><span class="line">              width: <span class="number">300</span>,</span><br><span class="line">              height: <span class="number">300</span>,</span><br><span class="line">              color: Colors.greenAccent,</span><br><span class="line">              child: FlutterLogo(),</span><br><span class="line">            ),</span><br><span class="line">            alignment: Alignment.center,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="/2020/07/08/Matrix-Transform/anim.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;矩阵概念及在Flutter中的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://www.xn--9hu.com/categories/flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://www.慌.com/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://www.慌.com/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2020-07-07T00:53:02.000Z</published>
    <updated>2020-07-08T00:50:40.963Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式原则可以帮助开发者提高代码的健壮性，可维护性。</p><a id="more"></a><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>概念：一个类应该有且只有一个引起类的变更的原因。</p><p>单一职责原则除了使代码逻辑更清晰，可读性更高外，主要是为了降低修改代码带来的风险，使程序更加易于维护。</p><p>单一职责原则不仅适用于类，也适用于方法。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>概念：所有父类出现的地方，有应该可以替换成它的子类，而不影响程序运行。</p><ul><li>子类必须重写父类的抽象方法，不能重写父类的非抽象方法；</li><li>子类可以扩展父类，增加特有方法；</li><li>子类复写父类的方法时，形参要比父类更宽松；</li><li>子类复写父类方法时，返回值要比父类更严格。</li></ul><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>概念：高层模块不应依赖底层模块；抽象不应依赖细节；细节应该依赖抽象。</p><ul><li><p>类的依赖通过抽象产生，实现类间不发生直接的依赖关系；</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖抽象类</p></li></ul><p>  “<strong>面向接口编程</strong>”</p><p>  依赖倒置原则可以减少并行开发的风险，提高系统稳定性和可维护性。</p><p>  “倒置”： 现实生活中的依赖关系都是依赖实实在在的东西，而依赖倒置原则要求类依赖抽象，而不是依赖实现类，此为倒置。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>概念：1. 客户端不应该依赖它不需要的接口；</p><pre><code>2. 类间的依赖关系应该建立在最小的接口上</code></pre><p>将接口细化，保证其纯洁性</p><h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>概念：一个对象应该对其他对象有最少的了解</p><ol><li><p>只和朋友交流</p><p>出现在成员便变量，方法的输入输出参数中的类称为朋友类，出现在方法体内部的类不属于朋友类。</p></li><li><p>朋友间也是有距离的</p><p>类的public方法或属性应尽量少，pulbic越多，修改时涉及的面越大，修改风险越大。</p></li><li><p>是自己的就是自己的</p><p>对于放在本类中和其他类中都可以的方法，如果放在本类中既不增加类间关系，也不对本类产生负面影响，则放在本类中。</p></li></ol><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>概念：一个软件实体如类、模块和函数应该对扩展开放，对修改封闭</p><p>软件实体应该通过扩展来实现变化而不是通过修改已有代码</p><p>好处：</p><ol><li>有利于测试，只需要测试扩展出的类</li><li>提高复用性</li><li>提供可维护性</li></ol><p>如何使用：</p><ol><li><p>抽象约束</p><p>通过接口或抽象类约束一组可能变化的行为</p></li><li><p>元数据控制模块行为</p></li><li><p>制定项目章程</p></li><li><p>封装变化</p><p>找出预计有变化或不稳定的点，为这些变化创建稳定的接口</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式原则可以帮助开发者提高代码的健壮性，可维护性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="http://www.xn--9hu.com/categories/programming/"/>
    
    
      <category term="design pattern" scheme="http://www.xn--9hu.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>BloC</title>
    <link href="http://www.慌.com/2020/07/05/BloC/"/>
    <id>http://www.慌.com/2020/07/05/BloC/</id>
    <published>2020-07-05T14:14:54.000Z</published>
    <updated>2020-07-06T12:23:16.541Z</updated>
    
    <content type="html"><![CDATA[<p>BLoC 模式分离了UI层和业务逻辑层，提供的event和state概念使代码逻辑逻辑更加清晰，易于维护，并提供了Observer等功能，方便调试。</p><a id="more"></a><h2 id="什么是BLoC"><a href="#什么是BLoC" class="headerlink" title="什么是BLoC"></a>什么是BLoC</h2><p>BLoC，全称Business Logic Component，业务逻辑部件，顾名思义，BLoC就是容纳业务逻辑的地方，并提供方法供UI层的Widget的访问，实现数据共享。</p><p>BLoC的结构如下图所示：</p><p><img src="/2020/07/05/BloC/bloc_structure.png" alt></p><p>BLoC本质上是一个stream，入口是event，通常是用户发起的“请求”，而输出的states就是BLoC根据内部的“Logic”，将用户请求转换为数据返回给UI层。</p><p>比如在官方的Counter Demo中，用户只要点击按钮，数字就加一，那么就可以定义一个叫<code>increment</code>的event，BLoC接收到这个event后，将之前的state加一并返回，这个stream的listener就会收到新state并刷新。</p><h2 id="为什么使用BLoC"><a href="#为什么使用BLoC" class="headerlink" title="为什么使用BLoC"></a>为什么使用BLoC</h2><p>BLoC模式有以下优点：</p><ul><li><p>使用简单</p><p>event -&gt; BLoC -&gt; state，逻辑简单，易于理解。同时Flutter Package中的bloc包和flutter_bloc包对BLoC模式进行了很好的封装，使用也很简单。</p></li><li><p>功能强大</p><p>比如BlocObserver可以onTransition回调中获取currentState和nextState，还有onEvent中获取添加到Bloc中的事件，在onError中捕获异常等，方便调试。</p></li><li><p>可测试</p><p>方便的添加event和获取state接口都使测试更容易。</p></li></ul><h2 id="如何使用BLoC"><a href="#如何使用BLoC" class="headerlink" title="如何使用BLoC"></a>如何使用BLoC</h2><p>下面实现一个常见的用户登录/注销功能。</p><ol><li>首先创建用户信息类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  UserInfo(&#123;<span class="keyword">this</span>.name, <span class="keyword">this</span>.age&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name: <span class="subst">$name</span>, age: <span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Event类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoEvent</span> </span>&#123;</span><br><span class="line">  UserInfoEvent(<span class="keyword">this</span>.eventId, &#123;<span class="keyword">this</span>.userInfo&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> login = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> logOut = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> eventId;</span><br><span class="line"></span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个类中主要是<code>login</code>和<code>logOut</code>两个变量，分别代表不同的事件。在登录时还需要传递用户信息过去，所以还需要在构造器中放一个<code>UserInfo</code>对象。</p><ol start="3"><li>创建Bloc类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">UserInfoEvent</span>, <span class="title">UserInfo</span>&gt; </span>&#123;</span><br><span class="line">  UserInfoBloc() : <span class="keyword">super</span>(UserInfo());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;UserInfo&gt; mapEventToState(UserInfoEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.eventId) &#123;</span><br><span class="line">      <span class="keyword">case</span> UserInfoEvent.login:</span><br><span class="line">        <span class="keyword">yield</span> event.userInfo;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UserInfoEvent.logOut:</span><br><span class="line">        <span class="keyword">yield</span> UserInfo();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造器中给bloc一个初始值，以便在用户未触发event时，widget知道显示什么信息；</p></li><li><p>最重要的是第二个方法 <code>mapEventToState</code>，这里就可以看出bloc就是stream。</p><p>mapEventToState中，根据不同的event，返回不同的对象，也就是需要在UI层显示的内容。</p></li></ul><ol start="4"><li>创建main入口</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    BlocProvider&lt;UserInfoBloc&gt;(</span><br><span class="line">      create: (context) =&gt; UserInfoBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        home: LoginRoute(),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里跟InheritedWidget一样，都是“lifting state up”，将state移在上面，下面的widget通过接口获取state，state在这里指UserInfoBloc。</p><ol start="5"><li>创建登录界面</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginRouteState createState() =&gt; _LoginRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  GlobalKey key = GlobalKey();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Form(</span><br><span class="line">            key: key,</span><br><span class="line">            child: Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                TextFormField(</span><br><span class="line">                  decoration: <span class="keyword">const</span> InputDecoration(labelText: <span class="string">'name'</span>),</span><br><span class="line">                  onSaved: (newValue) =&gt; name = newValue,</span><br><span class="line">                ),</span><br><span class="line">                TextFormField(</span><br><span class="line">                  decoration: <span class="keyword">const</span> InputDecoration(labelText: <span class="string">'age'</span>),</span><br><span class="line">                  onSaved: (newValue) =&gt; age = <span class="built_in">int</span>.parse(newValue),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          (key.currentState <span class="keyword">as</span> FormState).save();</span><br><span class="line">          context.bloc&lt;UserInfoBloc&gt;().add(UserInfoEvent(UserInfoEvent.login,</span><br><span class="line">              userInfo: UserInfo(name: name, age: age)));</span><br><span class="line">          Navigator.of(context).push(MaterialPageRoute(</span><br><span class="line">            builder: (context) =&gt; UserCenterRoute(),</span><br><span class="line">          ));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.done),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    登录界面中，context.bloc的add方法，将一个事件添加到UserInfoBloc的stream流中。</p><ol start="6"><li>创建个人信息页面</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCenterRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Container(</span><br><span class="line">          child: BlocBuilder&lt;UserInfoBloc, UserInfo&gt;(</span><br><span class="line">            builder: (context, state) &#123;</span><br><span class="line">              <span class="keyword">return</span> state.name != <span class="keyword">null</span> &amp;&amp; state.age != <span class="keyword">null</span></span><br><span class="line">                  ? Column(</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Text(</span><br><span class="line">                          <span class="string">'name: <span class="subst">$&#123;state.name&#125;</span>'</span>,</span><br><span class="line">                          style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">26</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        Text(</span><br><span class="line">                          <span class="string">'age: <span class="subst">$&#123;state.age&#125;</span>'</span>,</span><br><span class="line">                          style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">26</span>),</span><br><span class="line">                        ),</span><br><span class="line">                      ],</span><br><span class="line">                    )</span><br><span class="line">                  : Text(<span class="string">'no user info avaliable'</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; context</span><br><span class="line">            .bloc&lt;UserInfoBloc&gt;()</span><br><span class="line">            .add(UserInfoEvent(UserInfoEvent.logOut)),</span><br><span class="line">        child: Icon(Icons.exit_to_app),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlocBuilder监听UserInfoBloc中stream的流，获取其中的信息显示在UI界面上。</p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="BlocObserver"><a href="#BlocObserver" class="headerlink" title="BlocObserver"></a>BlocObserver</h3><p>BlocObserver提供了onEvent，onTransition，onError等回调，方便开发者看到stream的“流动”。</p><p>使用也很方便，只需继承BlocObserver，重写某个或所有方法。然后在main方法中给bloc.observer赋值即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleBlocObserver</span> <span class="keyword">extends</span> <span class="title">BlocObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onEvent(Bloc bloc, <span class="built_in">Object</span> event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(event);</span><br><span class="line">    <span class="keyword">super</span>.onEvent(bloc, event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onTransition(Bloc bloc, Transition transition) &#123;</span><br><span class="line">    <span class="built_in">print</span>(transition);</span><br><span class="line">    <span class="keyword">super</span>.onTransition(bloc, transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onError(Bloc bloc, <span class="built_in">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class="line">    <span class="built_in">print</span>(error);</span><br><span class="line">    <span class="keyword">super</span>.onError(bloc, error, stackTrace);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Bloc.observer = SimpleBlocObserver();</span><br><span class="line">  runApp(</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MultiBlocProvider"><a href="#MultiBlocProvider" class="headerlink" title="MultiBlocProvider"></a>MultiBlocProvider</h3><p>工程中通常会有很多个Bloc，MultiBlocProvider跟多层BlocProvider嵌套使用效果一样，但代码更加简洁，提高了代码可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MultiBlocProvider(</span><br><span class="line">  providers: [</span><br><span class="line">    BlocProvider&lt;BlocA&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocA(),</span><br><span class="line">    ),</span><br><span class="line">    BlocProvider&lt;BlocB&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocB(),</span><br><span class="line">    ),</span><br><span class="line">    BlocProvider&lt;BlocC&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocC(),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">  child: ChildA(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="BlocListener"><a href="#BlocListener" class="headerlink" title="BlocListener"></a>BlocListener</h3><p>BlocListener只在状态变化的时候被调用，不包括初始状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlocListener&lt;BlocA, BlocAState&gt;(</span><br><span class="line">  listener: (context, state) &#123;</span><br><span class="line">    &#x2F;&#x2F; do stuff here based on BlocA&#39;s state</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Container(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="BlocConsumer"><a href="#BlocConsumer" class="headerlink" title="BlocConsumer"></a>BlocConsumer</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BLoC 模式分离了UI层和业务逻辑层，提供的event和state概念使代码逻辑逻辑更加清晰，易于维护，并提供了Observer等功能，方便调试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://www.xn--9hu.com/categories/flutter/"/>
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>Provider</title>
    <link href="http://www.慌.com/2020/07/04/Provider/"/>
    <id>http://www.慌.com/2020/07/04/Provider/</id>
    <published>2020-07-04T09:28:53.000Z</published>
    <updated>2020-07-04T13:22:28.746Z</updated>
    
    <content type="html"><![CDATA[<p>Provider是对InheritedWidget的封装，简化了操作。</p><a id="more"></a><p>使用Provider时，无需手写InheritedWidget及包裹InheritedWidget的StatefulWidget，只需用<code>Provider</code>包裹，并在构造函数中传递数据既可。</p><p>数据模型需继承<code>ChangeNotifier</code>；</p><p>显示数据的Widget中，通过<code>Consumer</code>的<code>builder</code>获取数据或者<code>context.watch&lt;T&gt;()</code>；</p><p>修改数据的Widget中，使用<code>Provider.of(context, listen: false)</code>或者<code>context.read&lt;T&gt;()</code>获取数据对象并调用修改接口。</p><p>如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:provider/provider.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    n++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(</span><br><span class="line">      ChangeNotifierProvider(</span><br><span class="line">        create: (_) =&gt; CounterModel(),</span><br><span class="line">        child: MaterialApp(home: CounterPage()),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'provider'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          ShowWidget(),</span><br><span class="line">          CtrlWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// child: Text(context.watch&lt;CounterModel&gt;().n.toString()),</span></span><br><span class="line">      child: Consumer&lt;CounterModel&gt;(</span><br><span class="line">        builder: (context, value, child) &#123;</span><br><span class="line">          <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$&#123;value.n&#125;</span>'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () =&gt; context.read&lt;CounterModel&gt;().add(),</span><br><span class="line">        <span class="comment">// onPressed: () =&gt;</span></span><br><span class="line">        <span class="comment">//     Provider.of&lt;CounterModel&gt;(context, listen: false).add(),</span></span><br><span class="line">        child: Text(<span class="string">'add'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们甚至连StatefulWidget都不需要再写，代码量明显减少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Provider是对InheritedWidget的封装，简化了操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>InheritedWidget</title>
    <link href="http://www.慌.com/2020/07/02/InheritedWidget/"/>
    <id>http://www.慌.com/2020/07/02/InheritedWidget/</id>
    <published>2020-07-02T03:43:20.000Z</published>
    <updated>2020-07-04T09:06:54.585Z</updated>
    
    <content type="html"><![CDATA[<p>InheritedWidget是比较常用的状态管理方案，可以将数据沿widget树的从InheritedWidget向其子孙widget传递，从而实现widget间的数据共享。</p><a id="more"></a><h2 id="为什么要使用InheritedWidget"><a href="#为什么要使用InheritedWidget" class="headerlink" title="为什么要使用InheritedWidget"></a>为什么要使用InheritedWidget</h2><p>下面是一个Counter应用，CounterWidget有两个child，NumWidget和CtrlWidget，CounterWidget的数据需要传递到NumWidget，CtrlWidget需要修改CounterWidget的数据并在NumWidget中刷新，在Widget数量比较少时可以通过构造参数传递，但是一旦Widget的数量和深度变大就会变得难以管理，于是有了InheritedWidget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |CounterPage</span></span><br><span class="line"><span class="comment">// | |--NumWidget</span></span><br><span class="line"><span class="comment">// | |--CtrlWidget</span></span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="comment">//主Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            NumWidget(</span><br><span class="line">              number: n,</span><br><span class="line">            ),</span><br><span class="line">            CtrlWidget(</span><br><span class="line">              add: add,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示数字的Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  NumWidget(&#123;<span class="keyword">this</span>.number&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(widget.number.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加数字的Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  CtrlWidget(&#123;<span class="keyword">this</span>.add&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> VoidCallback add;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: widget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用InheritedWidget"><a href="#如何使用InheritedWidget" class="headerlink" title="如何使用InheritedWidget"></a>如何使用InheritedWidget</h2><p>新建一个Widget，继承InheritedWidget，并写一个of方法。这样无论需访问共享数据的Widget层级有多深，都可以通过of方法获取到InheritedWidget的实例，并访问其属性或调用方法。</p><p>CounterInheritedWidget要被包裹在一个StatefulWidget（CounterPage）中，通过setState改变并刷新数据。</p><p>CounterPage 刷新时，CounterInheritedWidget中的updateShouldNotify通过判断前后数据是否相同来决定是否通知通过context.dependOnInheritedWidgetOfExactType()对其监听的子Widget进行刷新。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  CounterInheritedWidget(&#123;<span class="keyword">this</span>.n = <span class="number">0</span>, <span class="keyword">this</span>.add, Widget child&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> n;</span><br><span class="line">  <span class="keyword">final</span> VoidCallback add;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> CounterInheritedWidget of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;CounterInheritedWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterInheritedWidget oldWidget) =&gt; n != oldWidget.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: CounterInheritedWidget(</span><br><span class="line">        n: n,</span><br><span class="line">        add: add,</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              NumWidget(),</span><br><span class="line">              CtrlWidget(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  CounterInheritedWidget inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(inheritedWidget.n.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  CounterInheritedWidget inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: inheritedWidget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的实现方式有个问题，InheritedWidget的属性和方法需要在本身构造函数内存在，还需要在包裹其的StatefulWidget中也声明对应的属性和方法，并通过InheritedWidget的构造器传递，比较麻烦，网上有一种比较好，也是我现在正在用的方式，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  CounterInheritedWidget(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.state, <span class="meta">@required</span> Widget child&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _CounterPageState state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _CounterPageState of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">        .dependOnInheritedWidgetOfExactType&lt;CounterInheritedWidget&gt;()</span><br><span class="line">        .state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterInheritedWidget oldWidget) =&gt;</span><br><span class="line">      state.n != oldWidget.state.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: CounterInheritedWidget(</span><br><span class="line">        state: <span class="keyword">this</span>,</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              NumWidget(),</span><br><span class="line">              CtrlWidget(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  _CounterPageState inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(inheritedWidget.n.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  _CounterPageState inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: inheritedWidget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将CounterInheritedWidget中of方法的返回改为_CounterPageState，这样就不用在CounterInheritedWidget中声明需要的属性和方法，只需要在_CounterPageState中声明即可，子孙widget直接访问，可以实现同样的功能。</p><h2 id="InheritedWidget是如何传递数据的"><a href="#InheritedWidget是如何传递数据的" class="headerlink" title="InheritedWidget是如何传递数据的"></a>InheritedWidget是如何传递数据的</h2><p>InheritedWidget实现沿widget树从上往下传递数据，从而实现子孙widget数据共享的关键在于BuildContext的dependOnInheritedWidgetOfExactType()方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Element在active和mount时都会调用这个方法</span></span><br><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">    ...</span><br><span class="line">    _inheritedWidgets[widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">T dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object</span> aspect&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets[T];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ancestor.updateDependencies(<span class="keyword">this</span>, aspect);</span><br><span class="line">    <span class="keyword">return</span> ancestor.widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updateDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> aspect) &#123;</span><br><span class="line">    setDependencies(dependent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> setDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> value) &#123;</span><br><span class="line">    _dependents[dependent] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看dependOnInheritedWidgetOfExactType的注释及源码可知，InheritedElement在active时，将自身this加入到一个HashMap&lt;Type, InheritedElement&gt;中，dependOnInheritedWidgetOfExactType&lt;T&gt;方法会去HashMap中获取key为T的Element，并返回其对应的Widget。</p><p>dependOnInheritedElement中还会把context自己加入到dependents中，并在Element <code>update</code>时，调用 dependent的didChangeDependencies，继而调用markNeedsBuild()实现刷新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InheritedWidget是比较常用的状态管理方案，可以将数据沿widget树的从InheritedWidget向其子孙widget传递，从而实现widget间的数据共享。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>Android启动模式及Flag</title>
    <link href="http://www.慌.com/2020/07/01/Android%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8AFlag/"/>
    <id>http://www.慌.com/2020/07/01/Android%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8AFlag/</id>
    <published>2020-07-01T02:47:23.000Z</published>
    <updated>2020-07-15T03:41:27.956Z</updated>
    
    <content type="html"><![CDATA[<p>Android有四种启动模式，分别是”standard”, “singleTop”, “singleTask”和“singleInstance”，跟Intent中的 <code>Flag_ACTIVITY_*</code> 一起定义Activity启动时的不同行为。</p><a id="more"></a><h2 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>Activity的默认启动模式，每次通过 <code>startActivity</code> 启动时都创建一个新实例。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>栈顶复用模式，如果Activity已处于栈顶，则复用，并调用Activity的<code>onNewIntent()</code>，否则创建新实例。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>启动Activity时，创建一个新栈，并创建的Activity实例放进去。如果在某个栈中已存在此Activity，则将其上面的Activity出栈，复用此Activity，并调用<code>onNewIntent()</code>。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>启动Activity是创建一个新栈，并创建的Activity实例放进去。跟singleTask不同的是，这个栈内只能有一个Activity，也就是说这个Activity启动Activity时，不会在其栈顶启动，而是启动在其他栈。</p><h2 id="Intent-Flags"><a href="#Intent-Flags" class="headerlink" title="Intent Flags"></a>Intent Flags</h2><p>Intent 中跟Activity启动相关的flag常用的有三个，<code>FLAG_ACTIVITY_NEW_TASK</code>，<code>FLAG_ACTIVITY_SINGLE_TOP</code>，<code>FLAG_ACTIVITY_CLEAR_TOP</code>。</p><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>作用同<code>singleTask</code>。</p><h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h3><p>作用同 <code>singleTop</code>。</p><h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h3><p>若当前栈已存在Activity实例，则将其上面的Activity出栈，并调用此Activity的<code>onNewIntent()</code>。</p><h3 id="为什么-FLAG-ACTIVITY-CLEAR-TOP经常跟FLAG-ACTIVITY-NEW-TASK一起用"><a href="#为什么-FLAG-ACTIVITY-CLEAR-TOP经常跟FLAG-ACTIVITY-NEW-TASK一起用" class="headerlink" title="为什么 FLAG_ACTIVITY_CLEAR_TOP经常跟FLAG_ACTIVITY_NEW_TASK一起用"></a>为什么 <code>FLAG_ACTIVITY_CLEAR_TOP</code>经常跟<code>FLAG_ACTIVITY_NEW_TASK</code>一起用</h3><p>使用<code>FLAG_ACTIVITY_NEW_TASK</code>，如果启动应用本身的Activity，跟不使用是一样的；如果启动的是其他应用的Activity，则会跳转到其他应用，并实例化一个新Activity。</p><p>例如，其他应用当前Activity状态时 A-&gt;B-&gt;C，以NEW_TASK启动B，结果是A-&gt;B-&gt;C-&gt;B</p><p>使用<code>FLAG_ACTIVITY_CLEAR_TOP</code>，如果启动应用本身的Activity，行为如上面描述；如果启动的是其他应用的Activity，则会在本应用内实例化一个Activity，也就是这个flag判断的是应用内是否存在Activity实例。</p><p>两个一起使用则可以实现跳转到目标应用，并将其上面的Activity出栈的效果。</p><p><strong>使用Intent flags启动Activity时，flag会覆盖Activity的launchmode指定的启动模式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android有四种启动模式，分别是”standard”, “singleTop”, “singleTask”和“singleInstance”，跟Intent中的 &lt;code&gt;Flag_ACTIVITY_*&lt;/code&gt; 一起定义Activity启动时的不同行为。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://www.xn--9hu.com/categories/android/"/>
    
    
      <category term="primary" scheme="http://www.xn--9hu.com/tags/primary/"/>
    
  </entry>
  
  <entry>
    <title>Google Technical Writing Course 笔记</title>
    <link href="http://www.慌.com/2020/04/20/Google%20Technical%20Writing%20Course/"/>
    <id>http://www.慌.com/2020/04/20/Google%20Technical%20Writing%20Course/</id>
    <published>2020-04-20T15:53:54.000Z</published>
    <updated>2020-07-01T05:50:47.027Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/tech-writing" target="_blank" rel="noopener">Google Technical Writing Course</a> 从用词、句子、段落等方面提高开发者的技术文档写作能力。</p><a id="more"></a><h2 id="用词"><a href="#用词" class="headerlink" title="用词"></a>用词</h2><ul><li><p><strong>定义对于目标读者是新的或不熟悉的单词</strong></p><p>如果单词在某个地方有详细解释，链接到那里。</p><p>如果文档本身是在介绍它，给它明确的定义。如果这种单词很多，放在术语章节中。</p></li><li><p><strong>使用一致的用词</strong></p><p>中途修改代码中的变量名会导致代码无法成功编译，文档也是。</p><p>如果某个名称太长，需要在下文使用缩写，可以加括号说明，如：</p><blockquote><p><strong>Protocol Buffers</strong> (or <strong>protobufs</strong> for short) provide their own definition language. Blah, blah, blah. And that’s why protobufs have won so many county fairs.</p></blockquote></li><li><p><strong>使用缩写</strong></p><p>使用某个名词的缩写前，先用粗体写明全称，如：</p><blockquote><p>This document is for engineers who are new to the <strong>Telekinetic Tactile Network</strong> (<strong>TTN</strong>) or need to understand how to order TTN replacement parts through finger motions.</p></blockquote><p>虽然使用缩写可以减短文章篇幅，但读者阅读时需要在大脑中转换成全称，增加了阅读成本。</p><p>使用缩写时应遵循以下两条规则：</p><ul><li>若文中很少用到，不要使用缩写。</li><li>缩写明显短于全称并在文中多次出现，可以使用缩写。</li></ul></li><li><p><strong>使用代词</strong></p><p>慎用代词，代词会让文章语义不清。</p><p>名词和代词之间距离应尽量近，如果名词和代词之间超过五个单词，考虑用名词，而不是代词。</p><p>如果名词和它的代词之间还有一个其他名词，使用名词，而不是代词。</p></li></ul><h2 id="主动句"><a href="#主动句" class="headerlink" title="主动句"></a>主动句</h2><ul><li><strong>避免使用被动句</strong>。</li></ul><p>​    读者需要在大脑中把被动句改为主动句，增加了阅读成本。</p><p>​    主动句比被动句表达的意思更清晰。</p><p>​    被动句经常省略主语，读者需要去猜测主语是什么。</p><p>​    主动句通常比被动句更短。</p><h2 id="清楚的句子"><a href="#清楚的句子" class="headerlink" title="清楚的句子"></a>清楚的句子</h2><ul><li><p><strong>使用”强烈“的动词</strong></p><p>动词在句子中扮演很重要的角色，为了加深句子表达的意思，我们应使用”strong“的动词，而不是”weak“的。</p><table><thead><tr><th>Weak Verb</th><th>Strong Verb</th></tr></thead><tbody><tr><td>The error <strong>occours</strong> when clicking the Submit button.</td><td>Clicking the submit button <strong>triggers</strong> the error.</td></tr><tr><td>This error message <strong>happens</strong> when …</td><td>The system <strong>generates</strong> this error message when…</td></tr><tr><td>We <strong>are</strong> very careful to ensure …</td><td>We carefully <strong>ensure</strong> …</td></tr></tbody></table></li><li><p><strong>少用 there is / there are</strong></p><ul><li><p>there is / there are 是一个太过宽泛普通的词，你应该给句子指定明确的名词和动词，如：</p><blockquote><p>There is a variable called <code>met_trick</code> that stores the current accuracy.</p></blockquote><p>应该改为</p><blockquote><p>A variable named <code>met_trick</code> stores the current accuracy. </p><p>The <code>met_trick</code> variable stores the current accuracy.</p></blockquote></li><li><p>有时可以通过把真实的主语和动词移到句子前面以减少 there is / there are 的使用，如：</p><blockquote><p>There are two disturbing facts about Perl you should know.</p></blockquote><p>使用 You 加强语句后</p><blockquote><p>You should know two disturbing fact about Prel.</p></blockquote></li><li><p>在没有主语的句子里，创造一个主语使句子语义更清晰。</p><blockquote><p>There is no guarantee that the updates will be received in sequential order.</p></blockquote><p>改为</p><blockquote><p>Clients might not receive the updates in sequential order.</p></blockquote></li></ul></li></ul><h2 id="简短的句子"><a href="#简短的句子" class="headerlink" title="简短的句子"></a>简短的句子</h2><p>文档简短有三点好处：更快阅读，更易维护，更少错误。</p><ul><li>一个句子只表达一个意思</li><li>把长句改为列表</li><li>消除无关单词</li><li>减少从句</li></ul><h2 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h2><ul><li><p><strong>选择正确的列表类型</strong></p><p>无序列表 OR 有序列表。</p></li><li><p><strong>保证列表子项”平行“</strong></p><p>语法，大小写，逻辑分类，标点符号 保持一致。</p></li><li><p><strong>恰当地使用标点符号</strong></p><p>如果子项是句子，则使用正确的大小写和标点符号。如果不是，不要加标点符号。</p></li><li><p><strong>有序列表开头使用必要的动词</strong></p><p>如 start、open，并遵顼”平行“的原则。</p></li><li><p><strong>创建有用的表格</strong></p><p>每列的头都应该清楚，有意义。</p><p>格子中的文字不要太多。</p></li><li><p><strong>介绍每个列表和表格</strong></p><p>给每个列表和表格简单说明，并以冒号结尾。</p></li></ul><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><ul><li><p><strong>写一个好的开头</strong></p><p>好的开头阐明本段的中心论点。</p></li><li><p><strong>每个段落集中说明一个单独的观点</strong></p></li><li><p><strong>别让段落太长或太短</strong></p><p>太长的段落看起来“吓人”。每段最好控制在三五行。</p><p>太多短段落会让文档看起来杂乱。</p></li><li><p><strong>好的段落回答了三个问题</strong></p><p>What 你在试图告诉读者什么。</p><p>Why 为什么知道这些对于读者很重要。</p><p>How 读者如何使用这些知识。</p></li></ul><h2 id="读者"><a href="#读者" class="headerlink" title="读者"></a>读者</h2><p>好文档 = 读者做某事需要知道的知识 - 读者已知的知识。</p><ul><li><strong>定义你的读者</strong></li><li><strong>决定你的读者需要学到什么</strong></li><li><strong>让文档适合你的读者</strong></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><p>声明文档的范围</p><p>在文档开头说明，本文档包含什么内容，不包含什么内容。 </p></li><li><p>声明读者范围</p><p>本文档为谁而写，适合哪些人。</p></li><li><p>概要</p><p>长文开头要阐明文档的中心论点，回答读者的问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developers.google.com/tech-writing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Technical Writing Course&lt;/a&gt; 从用词、句子、段落等方面提高开发者的技术文档写作能力。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://www.xn--9hu.com/tags/code/"/>
    
  </entry>
  
</feed>
