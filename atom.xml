<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>慌</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.慌.com/"/>
  <updated>2020-07-08T00:30:19.004Z</updated>
  <id>http://www.慌.com/</id>
  
  <author>
    <name>Paix Chen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://www.慌.com/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://www.慌.com/2020/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2020-07-07T00:53:02.000Z</published>
    <updated>2020-07-08T00:30:19.004Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>概念：一个类应该有且只有一个引起类的变更的原因。</p><p>单一职责原则除了使代码逻辑更清晰，可读性更高外，主要是为了降低修改代码带来的风险，使程序更加易于维护。</p><p>单一职责原则不仅适用于类，也适用于方法。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>概念：所有父类出现的地方，有应该可以替换成它的子类，而不影响程序运行。</p><ul><li>子类必须重写父类的抽象方法，不能重写父类的非抽象方法；</li><li>子类可以扩展父类，增加特有方法；</li><li>子类复写父类的方法时，形参要比父类更宽松；</li><li>子类复写父类方法时，返回值要比父类更严格。</li></ul><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>概念：高层模块不应依赖底层模块；抽象不应依赖细节；细节应该依赖抽象。</p><ul><li><p>类的依赖通过抽象产生，实现类间不发生直接的依赖关系；</p></li><li><p>接口或抽象类不依赖于实现类；</p></li><li><p>实现类依赖抽象类</p></li></ul><p>  “<strong>面向接口编程</strong>”</p><p>  依赖倒置原则可以减少并行开发的风险，提高系统稳定性和可维护性。</p><p>  “倒置”： 现实生活中的依赖关系都是依赖实实在在的东西，而依赖倒置原则要求类依赖抽象，而不是依赖实现类，此为倒置。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>概念：1. 客户端不应该依赖它不需要的接口；</p><pre><code>2. 类间的依赖关系应该建立在最小的接口上</code></pre><p>将接口细化，保证其纯洁性</p><h2 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h2><p>概念：一个对象应该对其他对象有最少的了解</p><ol><li><p>只和朋友交流</p><p>出现在成员便变量，方法的输入输出参数中的类称为朋友类，出现在方法体内部的类不属于朋友类。</p></li><li><p>朋友间也是有距离的</p><p>类的public方法或属性应尽量少，pulbic越多，修改时涉及的面越大，修改风险越大。</p></li><li><p>是自己的就是自己的</p><p>对于放在本类中和其他类中都可以的方法，如果放在本类中既不增加类间关系，也不对本类产生负面影响，则放在本类中。</p></li></ol><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>概念：一个软件实体如类、模块和函数应该对扩展开放，对修改封闭</p><p>软件实体应该通过扩展来实现变化而不是通过修改已有代码</p><p>好处：</p><ol><li>有利于测试，只需要测试扩展出的类</li><li>提高复用性</li><li>提供可维护性</li></ol><p>如何使用：</p><ol><li><p>抽象约束</p><p>通过接口或抽象类约束一组可能变化的行为</p></li><li><p>元数据控制模块行为</p></li><li><p>制定项目章程</p></li><li><p>封装变化</p><p>找出预计有变化或不稳定的点，为这些变化创建稳定的接口</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h2&gt;&lt;p&gt;概念：一个类应该有且只有一个引起类的变更的原因。&lt;/p&gt;
&lt;p&gt;单一职
      
    
    </summary>
    
    
      <category term="programming" scheme="http://www.xn--9hu.com/categories/programming/"/>
    
    
      <category term="design pattern" scheme="http://www.xn--9hu.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>BloC</title>
    <link href="http://www.慌.com/2020/07/05/BloC/"/>
    <id>http://www.慌.com/2020/07/05/BloC/</id>
    <published>2020-07-05T14:14:54.000Z</published>
    <updated>2020-07-06T12:23:16.541Z</updated>
    
    <content type="html"><![CDATA[<p>BLoC 模式分离了UI层和业务逻辑层，提供的event和state概念使代码逻辑逻辑更加清晰，易于维护，并提供了Observer等功能，方便调试。</p><a id="more"></a><h2 id="什么是BLoC"><a href="#什么是BLoC" class="headerlink" title="什么是BLoC"></a>什么是BLoC</h2><p>BLoC，全称Business Logic Component，业务逻辑部件，顾名思义，BLoC就是容纳业务逻辑的地方，并提供方法供UI层的Widget的访问，实现数据共享。</p><p>BLoC的结构如下图所示：</p><p><img src="/2020/07/05/BloC/bloc_structure.png" alt></p><p>BLoC本质上是一个stream，入口是event，通常是用户发起的“请求”，而输出的states就是BLoC根据内部的“Logic”，将用户请求转换为数据返回给UI层。</p><p>比如在官方的Counter Demo中，用户只要点击按钮，数字就加一，那么就可以定义一个叫<code>increment</code>的event，BLoC接收到这个event后，将之前的state加一并返回，这个stream的listener就会收到新state并刷新。</p><h2 id="为什么使用BLoC"><a href="#为什么使用BLoC" class="headerlink" title="为什么使用BLoC"></a>为什么使用BLoC</h2><p>BLoC模式有以下优点：</p><ul><li><p>使用简单</p><p>event -&gt; BLoC -&gt; state，逻辑简单，易于理解。同时Flutter Package中的bloc包和flutter_bloc包对BLoC模式进行了很好的封装，使用也很简单。</p></li><li><p>功能强大</p><p>比如BlocObserver可以onTransition回调中获取currentState和nextState，还有onEvent中获取添加到Bloc中的事件，在onError中捕获异常等，方便调试。</p></li><li><p>可测试</p><p>方便的添加event和获取state接口都使测试更容易。</p></li></ul><h2 id="如何使用BLoC"><a href="#如何使用BLoC" class="headerlink" title="如何使用BLoC"></a>如何使用BLoC</h2><p>下面实现一个常见的用户登录/注销功能。</p><ol><li>首先创建用户信息类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  UserInfo(&#123;<span class="keyword">this</span>.name, <span class="keyword">this</span>.age&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name: <span class="subst">$name</span>, age: <span class="subst">$age</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建Event类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoEvent</span> </span>&#123;</span><br><span class="line">  UserInfoEvent(<span class="keyword">this</span>.eventId, &#123;<span class="keyword">this</span>.userInfo&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> login = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> logOut = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> eventId;</span><br><span class="line"></span><br><span class="line">  UserInfo userInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个类中主要是<code>login</code>和<code>logOut</code>两个变量，分别代表不同的事件。在登录时还需要传递用户信息过去，所以还需要在构造器中放一个<code>UserInfo</code>对象。</p><ol start="3"><li>创建Bloc类</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfoBloc</span> <span class="keyword">extends</span> <span class="title">Bloc</span>&lt;<span class="title">UserInfoEvent</span>, <span class="title">UserInfo</span>&gt; </span>&#123;</span><br><span class="line">  UserInfoBloc() : <span class="keyword">super</span>(UserInfo());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Stream&lt;UserInfo&gt; mapEventToState(UserInfoEvent event) <span class="keyword">async</span>* &#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.eventId) &#123;</span><br><span class="line">      <span class="keyword">case</span> UserInfoEvent.login:</span><br><span class="line">        <span class="keyword">yield</span> event.userInfo;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> UserInfoEvent.logOut:</span><br><span class="line">        <span class="keyword">yield</span> UserInfo();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>构造器中给bloc一个初始值，以便在用户未触发event时，widget知道显示什么信息；</p></li><li><p>最重要的是第二个方法 <code>mapEventToState</code>，这里就可以看出bloc就是stream。</p><p>mapEventToState中，根据不同的event，返回不同的对象，也就是需要在UI层显示的内容。</p></li></ul><ol start="4"><li>创建main入口</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  runApp(</span><br><span class="line">    BlocProvider&lt;UserInfoBloc&gt;(</span><br><span class="line">      create: (context) =&gt; UserInfoBloc(),</span><br><span class="line">      child: MaterialApp(</span><br><span class="line">        home: LoginRoute(),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这里跟InheritedWidget一样，都是“lifting state up”，将state移在上面，下面的widget通过接口获取state，state在这里指UserInfoBloc。</p><ol start="5"><li>创建登录界面</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _LoginRouteState createState() =&gt; _LoginRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_LoginRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">LoginRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">int</span> age;</span><br><span class="line"></span><br><span class="line">  GlobalKey key = GlobalKey();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Form(</span><br><span class="line">            key: key,</span><br><span class="line">            child: Column(</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                TextFormField(</span><br><span class="line">                  decoration: <span class="keyword">const</span> InputDecoration(labelText: <span class="string">'name'</span>),</span><br><span class="line">                  onSaved: (newValue) =&gt; name = newValue,</span><br><span class="line">                ),</span><br><span class="line">                TextFormField(</span><br><span class="line">                  decoration: <span class="keyword">const</span> InputDecoration(labelText: <span class="string">'age'</span>),</span><br><span class="line">                  onSaved: (newValue) =&gt; age = <span class="built_in">int</span>.parse(newValue),</span><br><span class="line">                )</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          (key.currentState <span class="keyword">as</span> FormState).save();</span><br><span class="line">          context.bloc&lt;UserInfoBloc&gt;().add(UserInfoEvent(UserInfoEvent.login,</span><br><span class="line">              userInfo: UserInfo(name: name, age: age)));</span><br><span class="line">          Navigator.of(context).push(MaterialPageRoute(</span><br><span class="line">            builder: (context) =&gt; UserCenterRoute(),</span><br><span class="line">          ));</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Icon(Icons.done),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    登录界面中，context.bloc的add方法，将一个事件添加到UserInfoBloc的stream流中。</p><ol start="6"><li>创建个人信息页面</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCenterRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      body: SafeArea(</span><br><span class="line">        child: Container(</span><br><span class="line">          child: BlocBuilder&lt;UserInfoBloc, UserInfo&gt;(</span><br><span class="line">            builder: (context, state) &#123;</span><br><span class="line">              <span class="keyword">return</span> state.name != <span class="keyword">null</span> &amp;&amp; state.age != <span class="keyword">null</span></span><br><span class="line">                  ? Column(</span><br><span class="line">                      children: &lt;Widget&gt;[</span><br><span class="line">                        Text(</span><br><span class="line">                          <span class="string">'name: <span class="subst">$&#123;state.name&#125;</span>'</span>,</span><br><span class="line">                          style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">26</span>),</span><br><span class="line">                        ),</span><br><span class="line">                        Text(</span><br><span class="line">                          <span class="string">'age: <span class="subst">$&#123;state.age&#125;</span>'</span>,</span><br><span class="line">                          style: <span class="keyword">const</span> TextStyle(fontSize: <span class="number">26</span>),</span><br><span class="line">                        ),</span><br><span class="line">                      ],</span><br><span class="line">                    )</span><br><span class="line">                  : Text(<span class="string">'no user info avaliable'</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: () =&gt; context</span><br><span class="line">            .bloc&lt;UserInfoBloc&gt;()</span><br><span class="line">            .add(UserInfoEvent(UserInfoEvent.logOut)),</span><br><span class="line">        child: Icon(Icons.exit_to_app),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BlocBuilder监听UserInfoBloc中stream的流，获取其中的信息显示在UI界面上。</p><h2 id="更多功能"><a href="#更多功能" class="headerlink" title="更多功能"></a>更多功能</h2><h3 id="BlocObserver"><a href="#BlocObserver" class="headerlink" title="BlocObserver"></a>BlocObserver</h3><p>BlocObserver提供了onEvent，onTransition，onError等回调，方便开发者看到stream的“流动”。</p><p>使用也很方便，只需继承BlocObserver，重写某个或所有方法。然后在main方法中给bloc.observer赋值即可。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleBlocObserver</span> <span class="keyword">extends</span> <span class="title">BlocObserver</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onEvent(Bloc bloc, <span class="built_in">Object</span> event) &#123;</span><br><span class="line">    <span class="built_in">print</span>(event);</span><br><span class="line">    <span class="keyword">super</span>.onEvent(bloc, event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onTransition(Bloc bloc, Transition transition) &#123;</span><br><span class="line">    <span class="built_in">print</span>(transition);</span><br><span class="line">    <span class="keyword">super</span>.onTransition(bloc, transition);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> onError(Bloc bloc, <span class="built_in">Object</span> error, StackTrace stackTrace) &#123;</span><br><span class="line">    <span class="built_in">print</span>(error);</span><br><span class="line">    <span class="keyword">super</span>.onError(bloc, error, stackTrace);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  Bloc.observer = SimpleBlocObserver();</span><br><span class="line">  runApp(</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MultiBlocProvider"><a href="#MultiBlocProvider" class="headerlink" title="MultiBlocProvider"></a>MultiBlocProvider</h3><p>工程中通常会有很多个Bloc，MultiBlocProvider跟多层BlocProvider嵌套使用效果一样，但代码更加简洁，提高了代码可读性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MultiBlocProvider(</span><br><span class="line">  providers: [</span><br><span class="line">    BlocProvider&lt;BlocA&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocA(),</span><br><span class="line">    ),</span><br><span class="line">    BlocProvider&lt;BlocB&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocB(),</span><br><span class="line">    ),</span><br><span class="line">    BlocProvider&lt;BlocC&gt;(</span><br><span class="line">      create: (BuildContext context) &#x3D;&gt; BlocC(),</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">  child: ChildA(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="BlocListener"><a href="#BlocListener" class="headerlink" title="BlocListener"></a>BlocListener</h3><p>BlocListener只在状态变化的时候被调用，不包括初始状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlocListener&lt;BlocA, BlocAState&gt;(</span><br><span class="line">  listener: (context, state) &#123;</span><br><span class="line">    &#x2F;&#x2F; do stuff here based on BlocA&#39;s state</span><br><span class="line">  &#125;,</span><br><span class="line">  child: Container(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="BlocConsumer"><a href="#BlocConsumer" class="headerlink" title="BlocConsumer"></a>BlocConsumer</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BLoC 模式分离了UI层和业务逻辑层，提供的event和state概念使代码逻辑逻辑更加清晰，易于维护，并提供了Observer等功能，方便调试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="flutter" scheme="http://www.xn--9hu.com/categories/flutter/"/>
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>Provider</title>
    <link href="http://www.慌.com/2020/07/04/Provider/"/>
    <id>http://www.慌.com/2020/07/04/Provider/</id>
    <published>2020-07-04T09:28:53.000Z</published>
    <updated>2020-07-04T13:22:28.746Z</updated>
    
    <content type="html"><![CDATA[<p>Provider是对InheritedWidget的封装，简化了操作。</p><a id="more"></a><p>使用Provider时，无需手写InheritedWidget及包裹InheritedWidget的StatefulWidget，只需用<code>Provider</code>包裹，并在构造函数中传递数据既可。</p><p>数据模型需继承<code>ChangeNotifier</code>；</p><p>显示数据的Widget中，通过<code>Consumer</code>的<code>builder</code>获取数据或者<code>context.watch&lt;T&gt;()</code>；</p><p>修改数据的Widget中，使用<code>Provider.of(context, listen: false)</code>或者<code>context.read&lt;T&gt;()</code>获取数据对象并调用修改接口。</p><p>如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:provider/provider.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterModel</span> <span class="keyword">extends</span> <span class="title">ChangeNotifier</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    n++;</span><br><span class="line">    notifyListeners();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(</span><br><span class="line">      ChangeNotifierProvider(</span><br><span class="line">        create: (_) =&gt; CounterModel(),</span><br><span class="line">        child: MaterialApp(home: CounterPage()),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">'provider'</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          ShowWidget(),</span><br><span class="line">          CtrlWidget(),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// child: Text(context.watch&lt;CounterModel&gt;().n.toString()),</span></span><br><span class="line">      child: Consumer&lt;CounterModel&gt;(</span><br><span class="line">        builder: (context, value, child) &#123;</span><br><span class="line">          <span class="keyword">return</span> Text(<span class="string">'<span class="subst">$&#123;value.n&#125;</span>'</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: () =&gt; context.read&lt;CounterModel&gt;().add(),</span><br><span class="line">        <span class="comment">// onPressed: () =&gt;</span></span><br><span class="line">        <span class="comment">//     Provider.of&lt;CounterModel&gt;(context, listen: false).add(),</span></span><br><span class="line">        child: Text(<span class="string">'add'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们甚至连StatefulWidget都不需要再写，代码量明显减少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Provider是对InheritedWidget的封装，简化了操作。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>InheritedWidget</title>
    <link href="http://www.慌.com/2020/07/02/InheritedWidget/"/>
    <id>http://www.慌.com/2020/07/02/InheritedWidget/</id>
    <published>2020-07-02T03:43:20.000Z</published>
    <updated>2020-07-04T09:06:54.585Z</updated>
    
    <content type="html"><![CDATA[<p>InheritedWidget是比较常用的状态管理方案，可以将数据沿widget树的从InheritedWidget向其子孙widget传递，从而实现widget间的数据共享。</p><a id="more"></a><h2 id="为什么要使用InheritedWidget"><a href="#为什么要使用InheritedWidget" class="headerlink" title="为什么要使用InheritedWidget"></a>为什么要使用InheritedWidget</h2><p>下面是一个Counter应用，CounterWidget有两个child，NumWidget和CtrlWidget，CounterWidget的数据需要传递到NumWidget，CtrlWidget需要修改CounterWidget的数据并在NumWidget中刷新，在Widget数量比较少时可以通过构造参数传递，但是一旦Widget的数量和深度变大就会变得难以管理，于是有了InheritedWidget。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// |CounterPage</span></span><br><span class="line"><span class="comment">// | |--NumWidget</span></span><br><span class="line"><span class="comment">// | |--CtrlWidget</span></span><br><span class="line"></span><br><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="comment">//主Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">        ),</span><br><span class="line">        body: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            NumWidget(</span><br><span class="line">              number: n,</span><br><span class="line">            ),</span><br><span class="line">            CtrlWidget(</span><br><span class="line">              add: add,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示数字的Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  NumWidget(&#123;<span class="keyword">this</span>.number&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> number;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(widget.number.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加数字的Widget</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  CtrlWidget(&#123;<span class="keyword">this</span>.add&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> VoidCallback add;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: widget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何使用InheritedWidget"><a href="#如何使用InheritedWidget" class="headerlink" title="如何使用InheritedWidget"></a>如何使用InheritedWidget</h2><p>新建一个Widget，继承InheritedWidget，并写一个of方法。这样无论需访问共享数据的Widget层级有多深，都可以通过of方法获取到InheritedWidget的实例，并访问其属性或调用方法。</p><p>CounterInheritedWidget要被包裹在一个StatefulWidget（CounterPage）中，通过setState改变并刷新数据。</p><p>CounterPage 刷新时，CounterInheritedWidget中的updateShouldNotify通过判断前后数据是否相同来决定是否通知通过context.dependOnInheritedWidgetOfExactType()对其监听的子Widget进行刷新。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  CounterInheritedWidget(&#123;<span class="keyword">this</span>.n = <span class="number">0</span>, <span class="keyword">this</span>.add, Widget child&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> n;</span><br><span class="line">  <span class="keyword">final</span> VoidCallback add;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> CounterInheritedWidget of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;CounterInheritedWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterInheritedWidget oldWidget) =&gt; n != oldWidget.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: CounterInheritedWidget(</span><br><span class="line">        n: n,</span><br><span class="line">        add: add,</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              NumWidget(),</span><br><span class="line">              CtrlWidget(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  CounterInheritedWidget inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(inheritedWidget.n.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  CounterInheritedWidget inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: inheritedWidget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样的实现方式有个问题，InheritedWidget的属性和方法需要在本身构造函数内存在，还需要在包裹其的StatefulWidget中也声明对应的属性和方法，并通过InheritedWidget的构造器传递，比较麻烦，网上有一种比较好，也是我现在正在用的方式，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">main() =&gt; runApp(CounterPage());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  CounterInheritedWidget(&#123;<span class="meta">@required</span> <span class="keyword">this</span>.state, <span class="meta">@required</span> Widget child&#125;)</span><br><span class="line">      : <span class="keyword">super</span>(child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _CounterPageState state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> _CounterPageState of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">        .dependOnInheritedWidgetOfExactType&lt;CounterInheritedWidget&gt;()</span><br><span class="line">        .state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(CounterInheritedWidget oldWidget) =&gt;</span><br><span class="line">      state.n != oldWidget.state.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CounterPageState createState() =&gt; _CounterPageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CounterPageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CounterPage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  add() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      n++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: CounterInheritedWidget(</span><br><span class="line">        state: <span class="keyword">this</span>,</span><br><span class="line">        child: Scaffold(</span><br><span class="line">          appBar: AppBar(</span><br><span class="line">            title: Text(<span class="string">'Counter'</span>),</span><br><span class="line">          ),</span><br><span class="line">          body: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              NumWidget(),</span><br><span class="line">              CtrlWidget(),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _NumWidgetState createState() =&gt; _NumWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_NumWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">NumWidget</span>&gt; </span>&#123;</span><br><span class="line">  _CounterPageState inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: Text(inheritedWidget.n.toString()),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CtrlWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _CtrlWidgetState createState() =&gt; _CtrlWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_CtrlWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">CtrlWidget</span>&gt; </span>&#123;</span><br><span class="line">  _CounterPageState inheritedWidget;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    inheritedWidget = CounterInheritedWidget.of(context);</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      child: RaisedButton(</span><br><span class="line">        onPressed: inheritedWidget.add,</span><br><span class="line">        child: Text(<span class="string">'+'</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将CounterInheritedWidget中of方法的返回改为_CounterPageState，这样就不用在CounterInheritedWidget中声明需要的属性和方法，只需要在_CounterPageState中声明即可，子孙widget直接访问，可以实现同样的功能。</p><h2 id="InheritedWidget是如何传递数据的"><a href="#InheritedWidget是如何传递数据的" class="headerlink" title="InheritedWidget是如何传递数据的"></a>InheritedWidget是如何传递数据的</h2><p>InheritedWidget实现沿widget树从上往下传递数据，从而实现子孙widget数据共享的关键在于BuildContext的dependOnInheritedWidgetOfExactType()方法。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Element在active和mount时都会调用这个方法</span></span><br><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">    ...</span><br><span class="line">    _inheritedWidgets[widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">T dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object</span> aspect&#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets[T];</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object</span> aspect &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ancestor.updateDependencies(<span class="keyword">this</span>, aspect);</span><br><span class="line">    <span class="keyword">return</span> ancestor.widget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updateDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> aspect) &#123;</span><br><span class="line">    setDependencies(dependent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> setDependencies(<span class="built_in">Element</span> dependent, <span class="built_in">Object</span> value) &#123;</span><br><span class="line">    _dependents[dependent] = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看dependOnInheritedWidgetOfExactType的注释及源码可知，InheritedElement在active时，将自身this加入到一个HashMap&lt;Type, InheritedElement&gt;中，dependOnInheritedWidgetOfExactType&lt;T&gt;方法会去HashMap中获取key为T的Element，并返回其对应的Widget。</p><p>dependOnInheritedElement中还会把context自己加入到dependents中，并在Element <code>update</code>时，调用 dependent的didChangeDependencies，继而调用markNeedsBuild()实现刷新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InheritedWidget是比较常用的状态管理方案，可以将数据沿widget树的从InheritedWidget向其子孙widget传递，从而实现widget间的数据共享。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="state management" scheme="http://www.xn--9hu.com/tags/state-management/"/>
    
  </entry>
  
  <entry>
    <title>Android启动模式及Flag</title>
    <link href="http://www.慌.com/2020/07/01/Android%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8AFlag/"/>
    <id>http://www.慌.com/2020/07/01/Android%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8AFlag/</id>
    <published>2020-07-01T02:47:23.000Z</published>
    <updated>2020-07-01T13:02:49.658Z</updated>
    
    <content type="html"><![CDATA[<p>Android有四种启动模式，分别是”standard”, “singleTop”, “singleTask”和“singleInstance”，跟Intent中的 <code>Flag_ACTIVITY_*</code> 一起定义Activity启动时的不同行为。</p><a id="more"></a><h2 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>Activity的默认启动模式，每次通过 <code>startActivity</code> 启动时都创建一个新实例。</p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>栈顶复用模式，如果Activity已处于栈顶，则复用，并调用Activity的<code>onNewIntent()</code>，否则创建新实例。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>启动Activity时，创建一个新栈，并创建的Activity实例放进去。如果在某个栈中已存在此Activity，则将其上面的Activity出栈，复用此Activity，并调用<code>onNewIntent()</code>。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>启动Activity是创建一个新栈，并创建的Activity实例放进去。跟singleTask不同的是，这个栈内只能有一个Activity，也就是说这个Activity启动Activity时，不会在其栈顶启动，而是启动在其他栈。</p><h2 id="Intent-Flags"><a href="#Intent-Flags" class="headerlink" title="Intent Flags"></a>Intent Flags</h2><p>Intent 中跟Activity启动相关的flag常用的有三个，<code>FLAG_ACTIVITY_NEW_TASK</code>，<code>FLAG_ACTIVITY_SINGLE_TOP</code>，<code>FLAG_ACTIVITY_CLEAR_TOP</code>。</p><h3 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h3><p>作用同<code>singleTask</code>。</p><h3 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h3><p>作用同 <code>singleTop</code>。</p><h3 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h3><p>若当前栈已存在Activity实例，则将其上面的Activity出栈，并调用此Activity的<code>onNewIntent()</code>。</p><h3 id="为什么-FLAG-ACTIVITY-CLEAR-TOP经常跟FLAG-ACTIVITY-NEW-TASK一起用"><a href="#为什么-FLAG-ACTIVITY-CLEAR-TOP经常跟FLAG-ACTIVITY-NEW-TASK一起用" class="headerlink" title="为什么 FLAG_ACTIVITY_CLEAR_TOP经常跟FLAG_ACTIVITY_NEW_TASK一起用"></a>为什么 <code>FLAG_ACTIVITY_CLEAR_TOP</code>经常跟<code>FLAG_ACTIVITY_NEW_TASK</code>一起用</h3><p>使用<code>FLAG_ACTIVITY_NEW_TASK</code>，如果启动应用本身的Activity，跟不使用是一样的；如果启动的是其他应用的Activity，则会跳转到其他应用，并实例化一个新Activity。</p><p>例如，其他应用当前Activity状态时 A-&gt;B-&gt;C，以NEW_TASK启动B，结果是A-&gt;B-&gt;C-&gt;B</p><p>使用<code>FLAG_ACTIVITY_CLEAR_TOP</code>，如果启动应用本身的Activity，行为如上面描述；如果启动的是其他应用的Activity，则会在本应用内实例化一个Activity，也就是这个flag判断的是应用内是否存在Activity实例。</p><p>两个一起使用则可以实现跳转到目标应用，并将其上面的Activity出栈的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android有四种启动模式，分别是”standard”, “singleTop”, “singleTask”和“singleInstance”，跟Intent中的 &lt;code&gt;Flag_ACTIVITY_*&lt;/code&gt; 一起定义Activity启动时的不同行为。&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://www.xn--9hu.com/categories/android/"/>
    
    
      <category term="primary" scheme="http://www.xn--9hu.com/tags/primary/"/>
    
  </entry>
  
  <entry>
    <title>Google Technical Writing Course 笔记</title>
    <link href="http://www.慌.com/2020/04/20/Google%20Technical%20Writing%20Course/"/>
    <id>http://www.慌.com/2020/04/20/Google%20Technical%20Writing%20Course/</id>
    <published>2020-04-20T15:53:54.000Z</published>
    <updated>2020-07-01T05:50:47.027Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/tech-writing" target="_blank" rel="noopener">Google Technical Writing Course</a> 从用词、句子、段落等方面提高开发者的技术文档写作能力。</p><a id="more"></a><h2 id="用词"><a href="#用词" class="headerlink" title="用词"></a>用词</h2><ul><li><p><strong>定义对于目标读者是新的或不熟悉的单词</strong></p><p>如果单词在某个地方有详细解释，链接到那里。</p><p>如果文档本身是在介绍它，给它明确的定义。如果这种单词很多，放在术语章节中。</p></li><li><p><strong>使用一致的用词</strong></p><p>中途修改代码中的变量名会导致代码无法成功编译，文档也是。</p><p>如果某个名称太长，需要在下文使用缩写，可以加括号说明，如：</p><blockquote><p><strong>Protocol Buffers</strong> (or <strong>protobufs</strong> for short) provide their own definition language. Blah, blah, blah. And that’s why protobufs have won so many county fairs.</p></blockquote></li><li><p><strong>使用缩写</strong></p><p>使用某个名词的缩写前，先用粗体写明全称，如：</p><blockquote><p>This document is for engineers who are new to the <strong>Telekinetic Tactile Network</strong> (<strong>TTN</strong>) or need to understand how to order TTN replacement parts through finger motions.</p></blockquote><p>虽然使用缩写可以减短文章篇幅，但读者阅读时需要在大脑中转换成全称，增加了阅读成本。</p><p>使用缩写时应遵循以下两条规则：</p><ul><li>若文中很少用到，不要使用缩写。</li><li>缩写明显短于全称并在文中多次出现，可以使用缩写。</li></ul></li><li><p><strong>使用代词</strong></p><p>慎用代词，代词会让文章语义不清。</p><p>名词和代词之间距离应尽量近，如果名词和代词之间超过五个单词，考虑用名词，而不是代词。</p><p>如果名词和它的代词之间还有一个其他名词，使用名词，而不是代词。</p></li></ul><h2 id="主动句"><a href="#主动句" class="headerlink" title="主动句"></a>主动句</h2><ul><li><strong>避免使用被动句</strong>。</li></ul><p>​    读者需要在大脑中把被动句改为主动句，增加了阅读成本。</p><p>​    主动句比被动句表达的意思更清晰。</p><p>​    被动句经常省略主语，读者需要去猜测主语是什么。</p><p>​    主动句通常比被动句更短。</p><h2 id="清楚的句子"><a href="#清楚的句子" class="headerlink" title="清楚的句子"></a>清楚的句子</h2><ul><li><p><strong>使用”强烈“的动词</strong></p><p>动词在句子中扮演很重要的角色，为了加深句子表达的意思，我们应使用”strong“的动词，而不是”weak“的。</p><table><thead><tr><th>Weak Verb</th><th>Strong Verb</th></tr></thead><tbody><tr><td>The error <strong>occours</strong> when clicking the Submit button.</td><td>Clicking the submit button <strong>triggers</strong> the error.</td></tr><tr><td>This error message <strong>happens</strong> when …</td><td>The system <strong>generates</strong> this error message when…</td></tr><tr><td>We <strong>are</strong> very careful to ensure …</td><td>We carefully <strong>ensure</strong> …</td></tr></tbody></table></li><li><p><strong>少用 there is / there are</strong></p><ul><li><p>there is / there are 是一个太过宽泛普通的词，你应该给句子指定明确的名词和动词，如：</p><blockquote><p>There is a variable called <code>met_trick</code> that stores the current accuracy.</p></blockquote><p>应该改为</p><blockquote><p>A variable named <code>met_trick</code> stores the current accuracy. </p><p>The <code>met_trick</code> variable stores the current accuracy.</p></blockquote></li><li><p>有时可以通过把真实的主语和动词移到句子前面以减少 there is / there are 的使用，如：</p><blockquote><p>There are two disturbing facts about Perl you should know.</p></blockquote><p>使用 You 加强语句后</p><blockquote><p>You should know two disturbing fact about Prel.</p></blockquote></li><li><p>在没有主语的句子里，创造一个主语使句子语义更清晰。</p><blockquote><p>There is no guarantee that the updates will be received in sequential order.</p></blockquote><p>改为</p><blockquote><p>Clients might not receive the updates in sequential order.</p></blockquote></li></ul></li></ul><h2 id="简短的句子"><a href="#简短的句子" class="headerlink" title="简短的句子"></a>简短的句子</h2><p>文档简短有三点好处：更快阅读，更易维护，更少错误。</p><ul><li>一个句子只表达一个意思</li><li>把长句改为列表</li><li>消除无关单词</li><li>减少从句</li></ul><h2 id="列表和表格"><a href="#列表和表格" class="headerlink" title="列表和表格"></a>列表和表格</h2><ul><li><p><strong>选择正确的列表类型</strong></p><p>无序列表 OR 有序列表。</p></li><li><p><strong>保证列表子项”平行“</strong></p><p>语法，大小写，逻辑分类，标点符号 保持一致。</p></li><li><p><strong>恰当地使用标点符号</strong></p><p>如果子项是句子，则使用正确的大小写和标点符号。如果不是，不要加标点符号。</p></li><li><p><strong>有序列表开头使用必要的动词</strong></p><p>如 start、open，并遵顼”平行“的原则。</p></li><li><p><strong>创建有用的表格</strong></p><p>每列的头都应该清楚，有意义。</p><p>格子中的文字不要太多。</p></li><li><p><strong>介绍每个列表和表格</strong></p><p>给每个列表和表格简单说明，并以冒号结尾。</p></li></ul><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><ul><li><p><strong>写一个好的开头</strong></p><p>好的开头阐明本段的中心论点。</p></li><li><p><strong>每个段落集中说明一个单独的观点</strong></p></li><li><p><strong>别让段落太长或太短</strong></p><p>太长的段落看起来“吓人”。每段最好控制在三五行。</p><p>太多短段落会让文档看起来杂乱。</p></li><li><p><strong>好的段落回答了三个问题</strong></p><p>What 你在试图告诉读者什么。</p><p>Why 为什么知道这些对于读者很重要。</p><p>How 读者如何使用这些知识。</p></li></ul><h2 id="读者"><a href="#读者" class="headerlink" title="读者"></a>读者</h2><p>好文档 = 读者做某事需要知道的知识 - 读者已知的知识。</p><ul><li><strong>定义你的读者</strong></li><li><strong>决定你的读者需要学到什么</strong></li><li><strong>让文档适合你的读者</strong></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><p>声明文档的范围</p><p>在文档开头说明，本文档包含什么内容，不包含什么内容。 </p></li><li><p>声明读者范围</p><p>本文档为谁而写，适合哪些人。</p></li><li><p>概要</p><p>长文开头要阐明文档的中心论点，回答读者的问题。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developers.google.com/tech-writing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Technical Writing Course&lt;/a&gt; 从用词、句子、段落等方面提高开发者的技术文档写作能力。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="code" scheme="http://www.xn--9hu.com/tags/code/"/>
    
  </entry>
  
</feed>
